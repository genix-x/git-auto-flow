#!/usr/bin/env python3
"""
Gestionnaire multi-IA intelligent avec fallback automatique
"""

import os
from typing import Dict, Optional
from dotenv import load_dotenv


class AIProvider:
    """Gestionnaire intelligent multi-IA avec fallback automatique"""
    
    def __init__(self):
        """Initialise le gestionnaire multi-IA"""
        # Charge le fichier .env depuis le syst√®me global
        self._load_env_from_git_root()
        
        # Stockage des clients
        self.gemini_client = None
        self.groq_client = None
        
        # Configuration des APIs
        self.gemini_key = os.getenv('GEMINI_API_KEY')
        self.groq_key = os.getenv('GROQ_API_KEY')
        
        # √âtat des APIs (pour √©viter de retester une API qui a √©chou√©)
        self.gemini_available = bool(self.gemini_key)
        self.groq_available = bool(self.groq_key)
        
        if not (self.gemini_available or self.groq_available):
            env_path = os.path.expanduser('~/.env.gitautoflow')
            raise ValueError(
                "‚ùå Aucune cl√© API configur√©e!\n\n"
                "üí° Configurez vos cl√©s API en √©ditant le fichier .env:\n"
                f"   üìÑ {env_path}\n\n"
                "üîë Cl√©s disponibles:\n"
                "   GEMINI_API_KEY=votre_cle_gemini\n"
                "   GROQ_API_KEY=votre_cle_groq\n\n"
                "üîó Obtenir les cl√©s:\n"
                "   ‚Ä¢ Gemini: https://makersuite.google.com/app/apikey\n"
                "   ‚Ä¢ Groq: https://console.groq.com/keys\n\n"
                "‚ö° Ou relancez: ./install.sh pour configuration interactive"
            )
    
    def _load_env_from_git_root(self):
        """Charge le fichier .env depuis le home directory"""
        env_file = os.path.expanduser('~/.env.gitautoflow')
        if os.path.exists(env_file):
            load_dotenv(env_file)
            return
        
        # Fallback sur le fichier local si le global n'existe pas
        local_env = os.path.join(os.path.dirname(__file__), '../../.env')
        if os.path.exists(local_env):
            load_dotenv(local_env)
    
    def _get_gemini_client(self):
        """Initialise le client Gemini si pas encore fait"""
        if not self.gemini_client and self.gemini_available:
            try:
                # Import dynamique pour √©viter les erreurs de chemin
                import sys
                from pathlib import Path
                lib_path = Path(__file__).parent
                if str(lib_path) not in sys.path:
                    sys.path.insert(0, str(lib_path))
                
                from gemini_client import GeminiClient
                self.gemini_client = GeminiClient()
                return self.gemini_client
            except Exception as e:
                print(f"‚ö†Ô∏è  Gemini indisponible: {e}")
                self.gemini_available = False
                return None
        return self.gemini_client
    
    def _get_groq_client(self):
        """Initialise le client Groq si pas encore fait"""
        if not self.groq_client and self.groq_available:
            try:
                # Import dynamique pour √©viter les erreurs de chemin
                import sys
                from pathlib import Path
                lib_path = Path(__file__).parent
                if str(lib_path) not in sys.path:
                    sys.path.insert(0, str(lib_path))
                
                from groq_client import GroqClient
                self.groq_client = GroqClient(self.groq_key)
                return self.groq_client
            except Exception as e:
                print(f"‚ö†Ô∏è  Groq indisponible: {e}")
                self.groq_available = False
                return None
        return self.groq_client
    
    def analyze_for_commit(self, diff: str, files: str) -> Dict:
        """
        Analyse intelligente avec fallback automatique
        
        Args:
            diff: Le git diff des fichiers stag√©s
            files: La liste des fichiers modifi√©s
            
        Returns:
            Dict contenant les donn√©es du commit
        """
        # Tentative 1: Gemini (priorit√© 1)
        if self.gemini_available:
            try:
                print("ü§ñ Analyse avec Gemini...")
                client = self._get_gemini_client()
                if client:
                    return client.analyze_for_commit(diff, files)
            except Exception as e:
                print(f"‚ùå Gemini: {e}")
                print("üîÑ Fallback vers Groq...")
                self.gemini_available = False
        
        # Tentative 2: Groq (fallback)
        if self.groq_available:
            try:
                print("üöÄ Analyse avec Groq (fallback)...")
                client = self._get_groq_client()
                if client:
                    return client.analyze_for_commit(diff, files)
            except Exception as e:
                print(f"‚ùå Groq: {e}")
                self.groq_available = False
        
        # Aucune IA disponible
        raise RuntimeError(
            "‚ùå Aucune IA disponible!\n"
            "üí° V√©rifiez vos cl√©s API et votre connexion internet"
        )
    
    def analyze_for_pr(self, diff: str, files: str, target_branch: str = "develop") -> Dict:
        """
        Analyse intelligente pour PR avec fallback automatique
        
        Args:
            diff: Le git diff complet de la branche
            files: La liste des fichiers modifi√©s
            target_branch: La branche cible
            
        Returns:
            Dict contenant les donn√©es de la PR
        """
        # Tentative 1: Gemini (priorit√© 1)
        if self.gemini_available:
            try:
                print("ü§ñ G√©n√©ration PR avec Gemini...")
                client = self._get_gemini_client()
                if client:
                    return client.analyze_for_pr(diff, files, target_branch)
            except Exception as e:
                print(f"‚ùå Gemini: {e}")
                print("üîÑ Fallback vers Groq...")
                self.gemini_available = False
        
        # Tentative 2: Groq (fallback)
        if self.groq_available:
            try:
                print("üöÄ G√©n√©ration PR avec Groq (fallback)...")
                client = self._get_groq_client()
                if client:
                    return client.analyze_for_pr(diff, files, target_branch)
            except Exception as e:
                print(f"‚ùå Groq: {e}")
                self.groq_available = False
        
        # Aucune IA disponible
        raise RuntimeError(
            "‚ùå Aucune IA disponible!\n"
            "üí° V√©rifiez vos cl√©s API et votre connexion internet"
        )
    
    def analyze_for_release(self, diff: str, files: str, commits: list = None, latest_tag: str = "v0.0.0") -> Dict:
        """
        Analyse intelligente pour release PR avec fallback automatique
        
        Args:
            diff: Le git diff complet develop -> main
            files: La liste des fichiers modifi√©s
            commits: Liste des messages de commits
            latest_tag: Le dernier tag git pour le calcul de version
            
        Returns:
            Dict contenant les donn√©es de la PR de release
        """
        # Tentative 1: Gemini (priorit√© 1)
        if self.gemini_available:
            try:
                print("ü§ñ G√©n√©ration Release PR avec Gemini...")
                client = self._get_gemini_client()
                if client:
                    return client.analyze_for_release(diff, files, commits, latest_tag)
            except Exception as e:
                print(f"‚ùå Gemini: {e}")
                print("üîÑ Fallback vers Groq...")
                self.gemini_available = False
        
        # Tentative 2: Groq (fallback)
        if self.groq_available:
            try:
                print("üöÄ G√©n√©ration Release PR avec Groq (fallback)...")
                client = self._get_groq_client()
                if client:
                    return client.analyze_for_release(diff, files, commits, latest_tag)
            except Exception as e:
                print(f"‚ùå Groq: {e}")
                self.groq_available = False
        
        # Aucune IA disponible
        raise RuntimeError(
            "‚ùå Aucune IA disponible!\n"
            "üí° V√©rifiez vos cl√©s API et votre connexion internet"
        )

    def generate_response(self, prompt: str) -> Dict:
        """
        G√©n√®re une r√©ponse JSON g√©n√©rique avec fallback automatique
        """
        # Tentative 1: Gemini (priorit√© 1)
        if self.gemini_available:
            try:
                print("ü§ñ Analyse avec Gemini...")
                client = self._get_gemini_client()
                if client:
                    return client.generate_json_response(prompt)
            except Exception as e:
                print(f"‚ùå Gemini: {e}")
                print("üîÑ Fallback vers Groq...")
                self.gemini_available = False
        
        # Tentative 2: Groq (fallback)
        if self.groq_available:
            try:
                print("üöÄ Analyse avec Groq (fallback)...")
                client = self._get_groq_client()
                if client:
                    return client.generate_json_response(prompt)
            except Exception as e:
                print(f"‚ùå Groq: {e}")
                self.groq_available = False
        
        # Aucune IA disponible
        raise RuntimeError(
            "‚ùå Aucune IA disponible!\n"
            "üí° V√©rifiez vos cl√©s API et votre connexion internet"
        )
    
    def generate_tickets(self, content: str, context: str = "") -> dict:
        """
        G√©n√®re des tickets/issues depuis un compte-rendu avec IA
        """
        prompt = f'''
Analyse ce compte-rendu de projet et extrait les tickets/t√¢ches √† cr√©er comme issues GitHub.

COMPTE-RENDU:
{content}

CONTEXTE ADDITIONNEL:
{context}

Tu dois r√©pondre UNIQUEMENT avec un JSON valide dans ce format exact:
{{
  "tickets": [
    {{
      "title": "Titre concis et actionnable",
      "description": "Description d√©taill√©e avec crit√®res d'acceptance",
      "labels": ["enhancement", "priority-high"],
      "priority": "high",
      "estimate": "3"
    }}
  ]
}}

R√àGLES STRICTES:
- Maximum 5 tickets les plus prioritaires
- Titres courts et clairs (50 chars max)
- Descriptions avec bullet points et crit√®res d'acceptance
- Labels GitHub standards: bug, enhancement, documentation, good first issue, etc.
- Priority: high, medium, low
- Estimate: nombre de jours (1-5)
- Format JSON strict, pas de markdown autour
'''
        try:
            return self.generate_response(prompt)
        except Exception as e:
            raise RuntimeError(f"Erreur g√©n√©ration tickets: {e}")

    def get_status(self) -> str:
        """Retourne le statut des APIs disponibles"""
        status = []
        if self.gemini_available:
            status.append("‚úÖ Gemini")
        if self.groq_available:
            status.append("‚úÖ Groq")
        
        if not status:
            return "‚ùå Aucune IA disponible"
        
        return f"ü§ñ APIs: {', '.join(status)}"
